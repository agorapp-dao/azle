pub fn generate_header_code() -> proc_macro2::TokenStream {
    quote::quote! {
        // This code is automatically generated by Azle

        // #![allow(dead_code)]
        // #![allow(non_camel_case_types)]
        // #![allow(non_snake_case)]
        // #![allow(unused_imports)]
        // #![allow(unused_variables)]
        #![allow(warnings, unused)]

        use azle_vm_value_derive::{CdkActTryIntoVmValue, CdkActTryFromVmValue};
        use ic_cdk::api::call::CallResult;
        use rand::Rng;
        use sha2::Digest;
        use slotmap::Key;
        use std::str::FromStr;

        pub mod timers {
            pub struct TimerCallback {
                pub function: boa_engine::object::JsObject,
                pub timer_id: ic_cdk::timer::TimerId,
            }

            pub fn delete_timer_callback(timer_id: &ic_cdk::timer::TimerId) {
                crate::TIMER_CALLBACK_LOOKUP_REF_CELL.with(|timer_callback_lookup_ref_cell| {
                    let mut timer_callback_lookup = timer_callback_lookup_ref_cell.borrow_mut();

                    let timer_callback_id = timer_callback_lookup.get(&timer_id).unwrap().clone();

                    crate::TIMER_CALLBACKS_REF_CELL.with(|timer_callbacks_ref_cell| {
                        timer_callbacks_ref_cell.borrow_mut().remove(&timer_callback_id);
                    });

                    timer_callback_lookup.remove(&timer_id);
                    ic_cdk::println!("Removed timer {:?} with callback {}", timer_id, &timer_callback_id);
                });
            }

            pub fn create_callback_closure(callback_id: String) -> impl FnOnce() + 'static {
                move || {
                    unsafe {
                        ic_cdk::println!("Callback {} called", &callback_id);

                        let mut _azle_boa_context = crate::BOA_CONTEXT_OPTION.as_mut().unwrap();

                        let timer_id = crate::TIMER_CALLBACKS_REF_CELL.with(|timer_callbacks_ref_cell| {
                            let timer_callbacks = timer_callbacks_ref_cell.borrow();

                            let timer_callback = timer_callbacks.get(&callback_id).unwrap();

                            crate::_azle_handle_boa_result(
                                timer_callback.function.call(
                                    &boa_engine::JsValue::Null,
                                    &[],
                                    &mut *_azle_boa_context
                                ),
                                &mut *_azle_boa_context
                            );

                            timer_callback.timer_id
                        });

                        delete_timer_callback(&timer_id);
                    }
                }
            }
        }

        thread_local! {
            static RNG_REF_CELL: std::cell::RefCell<rand::rngs::StdRng>
                = std::cell::RefCell::new(rand::SeedableRng::from_seed([0u8;32]));
            static TIMER_CALLBACKS_REF_CELL: std::cell::RefCell<std::collections::HashMap<String, timers::TimerCallback>>
                = std::cell::RefCell::new(std::collections::HashMap::new());
            static TIMER_CALLBACK_LOOKUP_REF_CELL: std::cell::RefCell<std::collections::HashMap<ic_cdk::timer::TimerId, String>>
                = std::cell::RefCell::new(std::collections::HashMap::new());
        }

        fn _azle_create_uid() -> String {
            RNG_REF_CELL.with(|rng_ref_cell| {
                let mut rng = rng_ref_cell.borrow_mut();
                let random_values: [u8; 32] = rng.gen();
                let mut hasher = sha2::Sha224::new();
                hasher.update(random_values);
                let hash = hasher.finalize();
                base32::encode(base32::Alphabet::RFC4648 { padding: false }, &hash)
            })
        }
    }
}
